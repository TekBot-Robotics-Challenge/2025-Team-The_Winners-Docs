"use strict";(self.webpackChunktekbot=self.webpackChunktekbot||[]).push([[266],{358:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit1_3D-1c9596837e76aa485a1442b4b45448e7.png"},373:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img6-5cc55bdbad7d7601a2c315f27a95aa03.jpg"},929:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali5-5a0b346f7b7fca24ef38ddfc2291cfc5.jpg"},957:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali1-ea3b0ac693cca1963f0ff81b9f420c23.jpg"},1698:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali2-a44121cb4fa8ac1277aba2e335c03221.jpg"},1711:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"preselection/electronic/test2","title":"2nd Test","description":"Objectives","source":"@site/docs/preselection/electronic/test2.md","sourceDirName":"preselection/electronic","slug":"/preselection/electronic/test2","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/electronic/test2","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/preselection/electronic/test2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"preselectionSidebar","previous":{"title":"1rst Test","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/electronic/test1"},"next":{"title":"3rd Test","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/electronic/test3"}}');var r=i(4848),t=i(8453);const l={},d="2nd Test",c={},a=[{value:"Objectives",id:"objectives",level:2},{value:"Summary",id:"summary",level:2},{value:"Files available for download",id:"files-available-for-download",level:2},{value:"Materials",id:"materials",level:2},{value:"Black Box Circuit",id:"black-box-circuit",level:3},{value:"Signaling box",id:"signaling-box",level:3},{value:"Process",id:"process",level:2},{value:"Power Supply Design",id:"power-supply-design",level:3},{value:"Hardware design",id:"hardware-design",level:3},{value:"Circuit Design Process",id:"circuit-design-process",level:3},{value:"PCB Fabrication Process",id:"pcb-fabrication-process",level:4},{value:"Difficulties and Solving Approach",id:"difficulties-and-solving-approach",level:3},{value:"Software design",id:"software-design",level:3},{value:"Black box",id:"black-box",level:4},{value:"1. Includes et D\xe9finitions",id:"1-includes-et-d\xe9finitions",level:4},{value:"Biblioth\xe8ques incluses",id:"biblioth\xe8ques-incluses",level:4},{value:"2. Structure de donn\xe9es et Variables",id:"2-structure-de-donn\xe9es-et-variables",level:4},{value:"Structure MPUData",id:"structure-mpudata",level:4},{value:"Conteneurs de donn\xe9es MPU6050",id:"conteneurs-de-donn\xe9es-mpu6050",level:4},{value:"Variables de d\xe9tection de mouvement",id:"variables-de-d\xe9tection-de-mouvement",level:4},{value:"3. Fonction setup()",id:"3-fonction-setup",level:4},{value:"4. Fonction loop()",id:"4-fonction-loop",level:4},{value:"5. Fonction sendDataToControlStation()",id:"5-fonction-senddatatocontrolstation",level:4},{value:"Codes de mouvement",id:"codes-de-mouvement",level:4},{value:"Control station",id:"control-station",level:4},{value:"Includes and Configuration",id:"includes-and-configuration",level:4},{value:"Data Structure and Variables",id:"data-structure-and-variables",level:4},{value:"LED Configuration and Control Variables",id:"led-configuration-and-control-variables",level:4},{value:"LED Control Functions",id:"led-control-functions",level:4},{value:"Display and Debug Functions",id:"display-and-debug-functions",level:4},{value:"I2C Communication Function",id:"i2c-communication-function",level:4},{value:"Pictures",id:"pictures",level:2},{value:"Videos",id:"videos",level:2},{value:"Resources and Useful Links",id:"resources-and-useful-links",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"2nd-test",children:"2nd Test"})}),"\n",(0,r.jsxs)("div",{align:"justify",children:[(0,r.jsx)(n.h2,{id:"objectives",children:"Objectives"}),(0,r.jsx)(n.hr,{}),(0,r.jsx)(n.p,{children:"In industries like automotive, aviation, and rail, black boxes are essential for monitoring vehicle activity. These systems record various parameters; in aircraft, for instance, they log pilot communications and flight data such as speed, altitude, and spatial orientation using advanced sensors. This information is crucial for crash investigations."}),(0,r.jsx)(n.p,{children:"For the Tekbot Robotics Challenge, your task is to design a black box capable of recording speed and spatial position data using a gyroscope and accelerometer. This data must be transmitted in real time via I2C to a control station where it will be displayed on an LCD screen. The project has two components: a data-collecting/transmitting black box and a control station for receiving and displaying the data. You\u2019ll present the project through a video showing the box moving in space with its motion data visualized on the control station."}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Technical Requirements:"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reuse the same sensor as the previous project, meaning success depends on your earlier work."}),"\n",(0,r.jsx)(n.li,{children:"Use Atmega328P microcontrollers directly, not Arduino boards."}),"\n",(0,r.jsx)(n.li,{children:"Create electronic schematics using KICAD and design/produce your own PCBs."}),"\n",(0,r.jsx)(n.li,{children:"Build a 7 cm cube (the black box) with an open top if the material is opaque, to view the circuit inside."}),"\n",(0,r.jsx)(n.li,{children:"Design your own power supply (external to the cube)."}),"\n",(0,r.jsx)(n.li,{children:"Create an I2C bus where the microcontroller inside the cube is the only master, and the sensor (inside the cube) and control station microcontroller are slaves. The LCD should operate in 4-bit mode."}),"\n",(0,r.jsx)(n.li,{children:"As before, move the cube in all directions and display real-time data on the LCD."}),"\n",(0,r.jsx)(n.li,{children:"Document your work on the assigned GitHub repository."}),"\n"]}),(0,r.jsx)(n.hr,{}),(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),(0,r.jsx)(n.p,{children:"This documentation describes the design and fabrication of two custom PCBs:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One embedded inside a 7\xd77 cm cube (the black box) responsible for sensing and sending data over I2C."}),"\n",(0,r.jsx)(n.li,{children:"One external circuit acting as a control station that displays the data on an LCD in 4-bit mode and provides user feedback through LEDs."}),"\n"]}),(0,r.jsxs)(n.p,{children:["The boards were designed using ",(0,r.jsx)(n.em,{children:"KiCad"})," and produced via ",(0,r.jsx)(n.em,{children:"UV exposure and chemical etching"}),". Power supply and programming were handled via custom connectors and FTDI interfaces."]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h2,{id:"files-available-for-download",children:"Files available for download"}),(0,r.jsx)(n.p,{children:"Download the KiCad and Arduino files by following these links :"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"KiCad"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Black box : ",(0,r.jsx)(n.a,{href:"https://github.com/TekBot-Robotics-Challenge/2025-Team-The_Winners-Docs/blob/main/Tekbot_The_Winners/electonic/test2/kicad/black_box/Test_2.kicad_pro",children:"Black box KiCad file"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Control station : Black box : ",(0,r.jsx)(n.a,{href:"https://github.com/TekBot-Robotics-Challenge/2025-Team-The_Winners-Docs/blob/main/Tekbot_The_Winners/electonic/test2/kicad/station_control/Test_22.kicad_pro",children:"Control station KiCad file"})]}),"\n"]}),"\n"]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arduino"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Black box : ",(0,r.jsx)(n.a,{href:"https://github.com/TekBot-Robotics-Challenge/2025-Team-The_Winners-Docs/blob/main/Tekbot_The_Winners/electonic/test2/code/Test2_BLACK.BOX_TRC.ino",children:"Black box Arduino file"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Control station : ",(0,r.jsx)(n.a,{href:"https://github.com/TekBot-Robotics-Challenge/2025-Team-The_Winners-Docs/blob/main/Tekbot_The_Winners/electonic/test2/code/TEST2_CONTROL_STATION_TRC.ino",children:"Control station Arduino file"})]}),"\n"]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h2,{id:"materials",children:"Materials"}),(0,r.jsx)(n.p,{children:"List of components used for both the black box and signaling box."}),(0,r.jsx)(n.h3,{id:"black-box-circuit",children:"Black Box Circuit"}),(0,r.jsx)(n.p,{children:"Below is the list of the different components used for the design of the circuits in kiCad."}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Quantity"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ATmega328P"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Microcontroller"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"16MHz Quartz"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Clock source for the microcontroller"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"22pF Capacitors"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Polarization capacitors for the quartz"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MPU 6050"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Gyroscope and accelerometer sensor"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Push Button"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Reset button for the microcontroller"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"10k Resistor"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Pull-up resistor for the reset button"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"LED"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Indicator LED on pin 13"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Connectors"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"For FTDI programmer and signaling box connection (I2C connection)"})]})]})]}),(0,r.jsx)(n.h3,{id:"signaling-box",children:"Signaling box"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Quantity"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ATmega328P"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Microcontroller"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"16MHz Quartz"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Clock source for the microcontroller"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"22pF Capacitors"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Polarization capacitors for the quartz"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MPU 6050"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Gyroscope and accelerometer sensor"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Push Button"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Reset button for the microcontrolleur"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"10k Resistor"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Pull-up resistor for the reset button"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"LED"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Indicator LED on pin 13"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Connectors"}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"For FTDI programmer, black box connection (I2C connection), and LCD (in 4 bits mode)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"N-channel MOSFET"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Protection against polarity reversal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"LEDs"}),(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{children:"Indicator LEDs for movement directions of black box"})]})]})]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Tools and software:"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"KiCad for schematic and PCB design"}),"\n",(0,r.jsx)(n.li,{children:"UV exposure box"}),"\n",(0,r.jsx)(n.li,{children:"Ferric chloride (FeCl\u2083) for etching"}),"\n",(0,r.jsx)(n.li,{children:"Drill press for holes"}),"\n",(0,r.jsx)(n.li,{children:"Soldering station"}),"\n"]}),(0,r.jsx)(n.h2,{id:"process",children:"Process"}),(0,r.jsx)(n.h3,{id:"power-supply-design",children:"Power Supply Design"}),(0,r.jsx)(n.p,{children:"In this test, we were asked to design our own power supply. So, we used the power supply built during the first test."}),(0,r.jsx)(n.p,{children:"Here are the Pictures showing it :"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(957).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(1698).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(4367).A+"",width:"1200",height:"900"})})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(3556).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(929).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(3158).A+"",width:"900",height:"1200"})})]})})]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h3,{id:"hardware-design",children:"Hardware design"}),(0,r.jsx)(n.h3,{id:"circuit-design-process",children:"Circuit Design Process"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Schematic Design (KiCad):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Each circuit started with the basic ATmega328P configuration:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clock circuit: 16 MHz crystal + 2\xd722pF capacitors."}),"\n",(0,r.jsx)(n.li,{children:"Reset circuit: Push button with 10k\u03a9 pull-up."}),"\n",(0,r.jsx)(n.li,{children:"Status LED on digital pin 13."}),"\n",(0,r.jsx)(n.li,{children:"FTDI programming header (TX, RX, GND, VCC, DTR)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.em,{children:"Black Box"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"I2C connection to MPU6050."}),"\n",(0,r.jsx)(n.li,{children:"Header for I2C output to control station."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.em,{children:"Control Station"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"I2C input from Black Box."}),"\n",(0,r.jsx)(n.li,{children:"LCD interface in 4-bit mode."}),"\n",(0,r.jsx)(n.li,{children:"6 LEDs for visual feedback on motion along 6 directions."}),"\n",(0,r.jsx)(n.li,{children:"Polarity protection using a N-channel MOSFET."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"PCB Layout:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All components were placed to ensure compact design, short traces, and accessible connectors."}),"\n",(0,r.jsx)(n.li,{children:"Decoupling capacitors placed near power pins."}),"\n",(0,r.jsx)(n.li,{children:"Ground plane added to reduce noise."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Exporting and Printing:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Layouts were exported as mirrored PDF files and printed on transparent film for UV exposure."}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h4,{id:"pcb-fabrication-process",children:"PCB Fabrication Process"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"UV Exposure:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The printed film was placed over a photosensitive copper-clad board."}),"\n",(0,r.jsx)(n.li,{children:"Exposed to UV light for ~8 minutes."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Developing:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Board developed in sodium hydroxide solution to reveal copper traces."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Etching:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ferric chloride was used to remove unprotected copper."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Drilling and Soldering:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Holes drilled for through-hole components."}),"\n",(0,r.jsx)(n.li,{children:"Components soldered in place with attention to orientation and clearance."}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Boite noire"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Schematic capture:\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(6556).A+"",width:"1349",height:"805"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Printed circuit board overview :\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(6659).A+"",width:"782",height:"783"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(3566).A+"",width:"861",height:"816"})}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["3-D render of printed circuit board :\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(358).A+"",width:"935",height:"902"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Boite de signalisation"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Schematic capture: :\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(5359).A+"",width:"1242",height:"823"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Printed circuit board overview :\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(3310).A+"",width:"935",height:"777"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(4682).A+"",width:"1026",height:"815"})}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["3-D render of printed circuit board :\r\n",(0,r.jsx)(n.img,{alt:"Img1",src:i(5555).A+"",width:"1006",height:"801"})]}),"\n"]}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Time-lapse of PCB etching"}),"\n",(0,r.jsx)(n.li,{children:"Assembly of components"}),"\n",(0,r.jsx)(n.li,{children:"Test of LED indicator and MPU movement detection"}),"\n",(0,r.jsx)(n.li,{children:"Data shown in real time on LCD display"}),"\n"]}),(0,r.jsx)(n.h3,{id:"difficulties-and-solving-approach",children:"Difficulties and Solving Approach"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Problem"}),(0,r.jsx)(n.th,{children:"Solution"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Noise in sensor readings due to poor grounding"}),(0,r.jsx)(n.td,{children:"Added full ground plane and decoupling capacitors"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Difficulty programming ATmega328P directly"}),(0,r.jsx)(n.td,{children:"Used FTDI interface with DTR for smooth uploading"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"LCD flickering"}),(0,r.jsx)(n.td,{children:"Implemented delay and correct 4-bit wiring"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Power polarity inversion risk"}),(0,r.jsx)(n.td,{children:"Added MOSFET-based protection circuit"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Manual drilling imprecision"}),(0,r.jsx)(n.td,{children:"Used small drill bits with guided PCB holders"})]})]})]}),(0,r.jsx)(n.hr,{}),(0,r.jsx)(n.h3,{id:"software-design",children:"Software design"}),(0,r.jsx)(n.h4,{id:"black-box",children:"Black box"}),(0,r.jsx)(n.h4,{id:"1-includes-et-d\xe9finitions",children:"1. Includes et D\xe9finitions"}),(0,r.jsx)(n.h4,{id:"biblioth\xe8ques-incluses",children:"Biblioth\xe8ques incluses"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'#include "I2Cdev.h"'})," et ",(0,r.jsx)(n.code,{children:'#include "MPU6050_6Axis_MotionApps20.h"'})," : Ces biblioth\xe8ques sont sp\xe9cifiques au capteur MPU6050, particuli\xe8rement pour utiliser son processeur de mouvement num\xe9rique (DMP)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Source : ",(0,r.jsx)(n.a,{href:"https://github.com/jrowberg/i2cdevlib",children:"https://github.com/jrowberg/i2cdevlib"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"#include <Wire.h>"})," : Biblioth\xe8que Arduino standard pour la communication I2C (Inter-Integrated Circuit), essentielle pour communiquer avec le MPU6050 et la station de contr\xf4le."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MPU6050 mpu;"})," : Cr\xe9e une instance de l'objet MPU6050."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"#define CONTROL_STATION_ADDRESS 0x20"})," : D\xe9finit l'adresse I2C de la station de contr\xf4le, qui est l'esclave dans cette communication."]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h4,{id:"2-structure-de-donn\xe9es-et-variables",children:"2. Structure de donn\xe9es et Variables"}),(0,r.jsx)(n.h4,{id:"structure-mpudata",children:"Structure MPUData"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"struct MPUData"})," : Cette structure est con\xe7ue pour contenir toutes les donn\xe9es pertinentes du MPU6050 et les informations de mouvement calcul\xe9es. Cette structure doit correspondre \xe0 celle d\xe9finie dans le code de la station de contr\xf4le pour un \xe9change de donn\xe9es correct."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MPUData mpuData;"})," : Une instance de la structure MPUData pour stocker les donn\xe9es avant de les envoyer."]}),(0,r.jsx)(n.h4,{id:"conteneurs-de-donn\xe9es-mpu6050",children:"Conteneurs de donn\xe9es MPU6050"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Quaternion q;"})," : Stocke les composants du quaternion."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorInt16 aa;"})," : Stocke les donn\xe9es brutes de l'acc\xe9l\xe9rom\xe8tre."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorInt16 aaWorld;"})," : Stocke l'acc\xe9l\xe9ration corrig\xe9e de la gravit\xe9 dans le r\xe9f\xe9rentiel mondial."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorInt16 aaReal;"})," : Stocke les mesures du capteur d'acc\xe9l\xe9ration sans gravit\xe9."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorInt16 gy;"})," : Stocke les mesures du capteur gyroscope."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorFloat gravity;"})," : Stocke le vecteur de gravit\xe9."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"float ypr[3];"})," : Un tableau pour stocker les angles de lacet, tangage et roulis."]}),"\n"]}),(0,r.jsx)(n.h4,{id:"variables-de-d\xe9tection-de-mouvement",children:"Variables de d\xe9tection de mouvement"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VectorInt16 prevAccel = { 0, 0, 0 };"})," : Stocke les valeurs d'acc\xe9l\xe9ration pr\xe9c\xe9dentes pour calculer les diff\xe9rences d'acc\xe9l\xe9ration pour la d\xe9tection de mouvement."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"unsigned long prevTime = 0;"})," : Stocke l'horodatage pr\xe9c\xe9dent pour les calculs deltaTime."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"float movementThreshold = 1.0;"})," : Un seuil configurable (en m/s\xb2) pour d\xe9terminer si un mouvement est suffisamment significatif pour \xeatre d\xe9tect\xe9."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"byte lastMovementDetected = 0;"})," : Une variable globale pour stocker le dernier code de mouvement reconnu. C'est la valeur envoy\xe9e \xe0 la station de contr\xf4le. Les codes de mouvement vont de 0 (Pas de mouvement/Inactif) \xe0 6 (Arri\xe8re)."]}),"\n"]}),(0,r.jsx)(n.h4,{id:"3-fonction-setup",children:"3. Fonction setup()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void setup() {\r\n  // Initialize Wire as Master for both MPU6050 and Control Station communication\r\n  Wire.begin(); // Initializes the Wire library, setting the Arduino as an I2C Master.\r\n  Wire.setClock(400000); // Sets the I2C communication speed to 400kHz (fast mode).\r\n  pinMode(LED_BUILTIN, OUTPUT); //Configures the built-in LED as an output, likely for status indication.\r\n\r\n  // Initialize Serial for debugging (via USB-TTL if standalone ATMEGA)\r\n  Serial.begin(115200);\r\n  Serial.println(F("Initializing Black Box as I2C Master..."));\r\n  Serial.println(F("Initializing MPU6050..."));\r\n\r\n  // Initialize and test MPU6050 connection\r\n  mpu.initialize();\r\n  if (!mpu.testConnection()) { /* Checks if the MPU6050 connection is successful. If not, it prints an error and halts execution.*/\r\n    Serial.println("MPU6050 connection failed!");\r\n    while (1); // Stop execution if connection fails\r\n  }\r\n  Serial.println("MPU6050 connected.");\r\n\r\n  // Initialize the MPU6050 DMP\r\n  devStatus = mpu.dmpInitialize(); // Initializes the MPU6050\'s Digital Motion Processor (DMP).\r\n\r\n  // Set default calibration offsets (adjust if needed)\r\n  /*Sets default calibration offsets for the gyroscope and accelerometer.\r\n   These might need adjustment for specific sensor units.*/\r\n  mpu.setXGyroOffset(0);\r\n  mpu.setYGyroOffset(0);\r\n  mpu.setZGyroOffset(0);\r\n  mpu.setXAccelOffset(0);\r\n  mpu.setYAccelOffset(0);\r\n  mpu.setZAccelOffset(0);\r\n\r\n  if (devStatus == 0) {//Checks if DMP initialization was successful.\r\n    // Auto-calibration (may take a few seconds)\r\n    Serial.println(F("Calibrating MPU6050... Do not move."));\r\n    mpu.CalibrateAccel(6);\r\n    mpu.CalibrateGyro(6);\r\n    mpu.PrintActiveOffsets(); // Print offsets if you want to note them\r\n    Serial.println(F("Calibration complete."));\r\n   \r\n    mpu.setDMPEnabled(true);\r\n    DMPReady = true;\r\n    packetSize = mpu.dmpGetFIFOPacketSize(); //Gets the expected packet size from the DMP.\r\n    Serial.println(F("DMP ready."));\r\n  } else {\r\n    Serial.print("DMP initialization failed with code: ");\r\n    Serial.println(devStatus);\r\n    while (1); // Stop execution\r\n  }\r\n\r\n  // Initialize previous time for deltaTime calculation\r\n  prevTime = millis();\r\n \r\n  Serial.println(F("Black Box Master ready. Searching for Control Station..."));\r\n \r\n//************************************************************\r\n    digitalWrite(LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)\r\n    delay(1000);                      // wait for a second\r\n    digitalWrite(LED_BUILTIN, LOW);   // turn the LED off by making the voltage LOW\r\n    delay(1000);                      // wait for a second\r\n   \r\n//************************************************************\r\n}\n'})}),(0,r.jsx)(n.h4,{id:"4-fonction-loop",children:"4. Fonction loop()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// LOOP FUNCTION\r\n// ================================================================\r\nvoid loop() {\r\n  if (!DMPReady) return; // Make sure DMP is ready before proceeding\r\n\r\n  if (mpu.dmpGetCurrentFIFOPacket(FIFOBuffer)) { // Check if a new packet is available in FIFO\r\n    // Read current time and calculate deltaTime (for future use, not directly for detection here)\r\n    unsigned long currentTime = millis();\r\n    float deltaTime = (currentTime - prevTime) / 1000.0;\r\n    prevTime = currentTime;\r\n\r\n    // Retrieve DMP data\r\n    mpu.dmpGetQuaternion(&q, FIFOBuffer);\r\n    mpu.dmpGetGravity(&gravity, &q);\r\n    mpu.dmpGetAccel(&aa, FIFOBuffer);\r\n    mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);\r\n    mpu.dmpConvertToWorldFrame(&aaWorld, &aa, &q); // Converts acceleration to the world frame, removing gravity.\r\n    mpu.dmpGetGyro(&gy, FIFOBuffer);\r\n    mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);\r\n\r\n    // Fill MPU data structure\r\n    // World frame accelerations in m/s\xb2\r\n    mpuData.ax = aaWorld.x * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2;\r\n    mpuData.ay = aaWorld.y * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2;\r\n    mpuData.az = aaWorld.z * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2;\r\n   \r\n    // Gyroscope data in degrees/second\r\n    mpuData.gx = gy.x * mpu.get_gyro_resolution();\r\n    mpuData.gy = gy.y * mpu.get_gyro_resolution();\r\n    mpuData.gz = gy.z * mpu.get_gyro_resolution();\r\n   \r\n    // Quaternion components\r\n    mpuData.qw = q.w;\r\n    mpuData.qx = q.x;\r\n    mpuData.qy = q.y;\r\n    mpuData.qz = q.z;\r\n   \r\n    // Euler angles in degrees\r\n    mpuData.yaw = ypr[0] * 180/M_PI;\r\n    mpuData.pitch = ypr[1] * 180/M_PI;\r\n    mpuData.roll = ypr[2] * 180/M_PI;\r\n   \r\n    // Temperature in Celsius\r\n    mpuData.temperature = mpu.getTemperature() / 340.0 + 36.53;\r\n\r\n    // Compute real accelerations in m/s\xb2\r\n    float ax = mpuData.ax;\r\n    float ay = mpuData.ay;\r\n    float az = mpuData.az;\r\n\r\n    // Compute acceleration differences (acceleration derivative)\r\n    float dx = ax - (prevAccel.x * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2);\r\n    float dy = ay - (prevAccel.y * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2);\r\n    float dz = az - (prevAccel.z * mpu.get_acce_resolution() * EARTH_GRAVITY_MS2);\r\n\r\n    // Absolute values of differences\r\n    float absDx = abs(dx);\r\n    float absDy = abs(dy);\r\n    float absDz = abs(dz);\r\n\r\n    lastMovementDetected = 0; // No movement by default\r\n\r\n    // ================================================================\r\n    // MOVEMENT DETECTION LOGIC (6 DIRECTIONS)\r\n    // ================================================================\r\n    bool movementDetected = false;\r\n   \r\n    if (absDx > absDy && absDx > absDz && absDx > movementThreshold) {\r\n      mpuData.dominantAccel = absDx;\r\n      movementDetected = true;\r\n      if (dx > 0) {\r\n        // Movement "Right"\r\n        mpuData.movementCode = 4; // Code for Right\r\n        lastMovementDetected = 4;\r\n        Serial.print("Right\\t\\t");\r\n      } else {\r\n        // Movement "Left"\r\n        mpuData.movementCode = 3; // Code for Left\r\n        lastMovementDetected = 3;\r\n        Serial.print("Left\\t\\t");\r\n      }\r\n      Serial.print(absDx, 2);\r\n      Serial.println(" m/s\xb2");\r\n    } else if (absDy > absDx && absDy > absDz && absDy > movementThreshold) {\r\n      mpuData.dominantAccel = absDy;\r\n      movementDetected = true;\r\n      if (dy > 0) {\r\n        // Movement "Forward" (Push)\r\n        mpuData.movementCode = 5; // Code for Forward\r\n        lastMovementDetected = 5;\r\n        Serial.print("Forward (Push)\\t");\r\n      } else {\r\n        // Movement "Backward" (Pull)\r\n        mpuData.movementCode = 6; // Code for Backward\r\n        lastMovementDetected = 6;\r\n        Serial.print("Backward (Pull)\\t");\r\n      }\r\n      Serial.print(absDy, 2);\r\n      Serial.println(" m/s\xb2");\r\n    } else if (absDz > absDx && absDz > absDy && absDz > movementThreshold) {\r\n      mpuData.dominantAccel = absDz;\r\n      movementDetected = true;\r\n      if (dz > 0) {\r\n        // Movement "Down"\r\n        mpuData.movementCode = 2; // Code for Down\r\n        lastMovementDetected = 2;\r\n        Serial.print("Down\\t\\t");\r\n      } else {\r\n        // Movement "Up"\r\n        mpuData.movementCode = 1; // Code for Up\r\n        lastMovementDetected = 1;\r\n        Serial.print("Up\\t\\t");\r\n      }\r\n      Serial.print(absDz, 2);\r\n      Serial.println(" m/s\xb2");\r\n    } else {\r\n      // No significant movement\r\n      mpuData.movementCode = 0; // Code for None\r\n      mpuData.dominantAccel = 0.0;\r\n      lastMovementDetected = 0;\r\n      Serial.println("No significant movement.");\r\n    }\r\n\r\n    // Send data to control station whenever there\'s a change in movement\r\n    // or periodically even if no movement (you can adjust this logic)\r\n    sendDataToControlStation(); // Calls a function to transmit the populated\r\n\r\n    // Update previous acceleration for next cycle\r\n    prevAccel = aaWorld;\r\n    Serial.println(); // Blank line for Serial Monitor readability\r\n  }\r\n \r\n  // Small delay to avoid overwhelming the I2C bus\r\n  delay(100);\r\n}\n'})}),(0,r.jsx)(n.h4,{id:"5-fonction-senddatatocontrolstation",children:"5. Fonction sendDataToControlStation()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Function to send complete MPU data to control station\r\nvoid sendDataToControlStation() {\r\n  // Send the complete MPU data structure\r\n  Wire.beginTransmission(CONTROL_STATION_ADDRESS); //Initiates an I2C transmission to the Control Station at its defined address\r\n \r\n  Wire.write((byte*)&mpuData, sizeof(MPUData)); /* Writes the entire mpuData structure as a byte array over\r\n  the I2C bus. sizeof(MPUData) ensures all bytes of the structure are sent */\r\n \r\n  byte result = Wire.endTransmission(); // Ends the transmission and returns a byte indicating\r\n  //the success or failure of the transmission\r\n \r\n  if (result != 0) {\r\n    Serial.print("I2C transmission error: ");\r\n    Serial.println(result);\r\n  }\r\n}\n'})}),(0,r.jsx)(n.h4,{id:"codes-de-mouvement",children:"Codes de mouvement"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Code"}),(0,r.jsx)(n.th,{children:"Mouvement"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Aucun mouvement/Inactif"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Haut"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Bas"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Gauche"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"Droite"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"Avant (Pouss\xe9e)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{children:"Arri\xe8re (Traction)"})]})]})]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h4,{id:"control-station",children:"Control station"}),(0,r.jsx)(n.h4,{id:"includes-and-configuration",children:"Includes and Configuration"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <Wire.h> // Essential for I2C communication  \r\n#include <LiquidCrystal.h> // Used to interface with and control the LCD display  \n"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.em,{children:"Wire.h"})," and ",(0,r.jsx)(n.em,{children:"LiquidCrystal.h"})," are integrated or native libraries, directly incorporated into Arduino IDE"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"LiquidCrystal lcd(6, 7, 2, 3, 4, 5); : Initializes an LCD object with the specified pin connections in 4-bit mode"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"#define CONTROL_STATION_ADDRESS 0x20 : Defines the I2C address for the Control Station as a slave device"}),"\n"]}),"\n"]}),(0,r.jsx)(n.h4,{id:"data-structure-and-variables",children:"Data Structure and Variables"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"struct MPUData : Defined to hold MPU6050 sensor data received from the master"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"MPUData receivedData : Stores the latest received data"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"volatile bool newDataReceived = false; : Flag for new I2C data, declared volatile due to ISR modification"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"volatile byte dataBuffer[sizeof(MPUData)]; : Buffer for incoming I2C data"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"volatile byte bufferIndex = 0; : Index for tracking position in dataBuffer"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"byte displayMode = 0; : Controls current LCD display mode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"0: Movement info"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"1: Accelerations"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"2: Gyro"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"3: Angles"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"4: Quaternions"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"5: Temperature"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.p,{children:"const char* movementNames[] : Maps movementCode to readable names"}),(0,r.jsx)(n.h4,{id:"led-configuration-and-control-variables",children:"LED Configuration and Control Variables"}),(0,r.jsx)(n.p,{children:"In setup() Function"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'pinMode(ledX, OUTPUT);\r\nturnOffAllLeds();\r\nlcd.clear();\r\nlcd.setCursor(0, 0); lcd.print("Control Station");\r\nlcd.setCursor(0, 1); lcd.print("Waiting...");\r\nWire.begin(CONTROL_STATION_ADDRESS);\r\nWire.onReceive(receiveEvent);\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Serial prints confirm initialization and I2C address"}),"\n"]}),(0,r.jsx)(n.p,{children:"loop() Function"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"displayMode = (displayMode + 1) % 6;\n"})}),(0,r.jsx)(n.h4,{id:"led-control-functions",children:"LED Control Functions"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"turnOffAllLeds() : Sets all LED pins to LOW (off)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"updateLedStatus() : Activates LED based on receivedData.movementCode"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"0 (IDLE): No LED, blinking handled by handleLedBlinking()"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"1\u20136: Corresponding LED is set HIGH"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Unknown: Calls blinkAllLedsError()"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"handleLedBlinking() : If IDLE, toggles LEDs every BLINK_INTERVAL (500ms)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"blinkAllLedsError() : All LEDs blink rapidly at ERROR_BLINK_INTERVAL (150ms)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"updateLedIntensityPattern() :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Computes 3D acceleration magnitude"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Determines number of LEDs to light based on magnitude thresholds"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h4,{id:"display-and-debug-functions",children:"Display and Debug Functions"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"printAllDataToSerial() :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Prints all received MPU6050 data to Serial Monitor"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Includes movement, dominant acceleration, accelerations, gyroscope, Euler angles, quaternions, temperature"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"updateLCDDisplay() :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Based on displayMode value, shows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"0: Movement name & dominant acceleration"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"1: X, Y, Z accelerations"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"2: X, Y, Z gyroscope values"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"3: Yaw, Pitch, Roll angles"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"4: Quaternions W, X, Y (Z not shown \u2014 likely oversight)"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"5: Temperature in Celsius"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h4,{id:"i2c-communication-function",children:"I2C Communication Function"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"receiveEvent(int bytesReceived) : ISR triggered when I2C master sends data"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Resets bufferIndex"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Reads bytes from I2C using Wire.available()"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Stores bytes into dataBuffer[]"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If buffer is complete (bufferIndex >= sizeof(MPUData)):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Copies content to receivedData using memcpy()"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Sets newDataReceived = true"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.h2,{id:"pictures",children:"Pictures"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(5902).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(9609).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(4236).A+"",width:"900",height:"1200"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(8583).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(7770).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(373).A+"",width:"900",height:"1200"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(4360).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(2499).A+"",width:"900",height:"1200"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(9334).A+"",width:"1200",height:"900"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(6100).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(4145).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(4566).A+"",width:"1200",height:"900"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img1",src:i(7731).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img2",src:i(6800).A+"",width:"1200",height:"900"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.img,{alt:"Img3",src:i(6029).A+"",width:"1200",height:"900"})})]})]})]}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://tekbot-robotics-challenge.github.io/2025-Team-The_Winners-Docs/docs/media/photos",children:(0,r.jsx)(n.strong,{children:"See more..."})})}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h2,{id:"videos",children:"Videos"}),(0,r.jsx)("center",{children:(0,r.jsx)("iframe",{src:"https://www.veed.io/view/9613f65a-d015-4504-a7a8-07a7bd65d4e3?panel=share",width:"800",height:"600",frameborder:"0",allowfullscreen:!0})}),(0,r.jsx)("center",{children:(0,r.jsx)("iframe",{src:"https://www.veed.io/view/1c5e7b7f-2bbb-40c7-aff7-5f915bc05bf0?panel=share",width:"800",height:"600",frameborder:"0",allowfullscreen:!0})}),(0,r.jsx)("br",{}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://tekbot-robotics-challenge.github.io/2025-Team-The_Winners-Docs/docs/media/videos",children:(0,r.jsx)(n.strong,{children:"See more..."})})}),(0,r.jsx)("br",{}),(0,r.jsx)(n.h2,{id:"resources-and-useful-links",children:"Resources and Useful Links"}),(0,r.jsx)(n.p,{children:"Provide links to resources, tutorials, and any other useful information that was referenced during the project."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.kicad.org/",children:"KiCad Official Website"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf",children:"ATmega328P Datasheet"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf",children:"MPU 6050 Datasheet"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.instructables.com/How-to-Make-PCB-Using-Inkjet-Printer/",children:"PCB Fabrication Tutorial"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.arduino.cc/en/Tutorial/BuiltInExamples/ArduinoToBreadboard",children:"Arduino to ATmega328P Standalone Setup"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=Ycs0t7YHEOE",children:"How to etch PCBs at home (video)"})}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},2499:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img8-1edbe0b65859d46d84f2af6aac510338.jpg"},3158:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali6-d1d297d8541f786d5d397ebba2e1ab0a.jpg"},3310:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit2_pcb2-ccc407a3aa6eabfc69473b82ee86ac4a.png"},3556:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali4-6a12297363b32fae4fcbff254b369b12.jpg"},3566:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit1_pcb2-c1c968e8f5c6d1c7f5f23f5cedea1027.png"},4145:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img11-9829c9751dc44332579badc8bc6c5115.jpg"},4236:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img3-15c495afd420daac525ad6cf4657bf99.jpg"},4360:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img7-b08da5edd1117df92397d0e50e48d9cb.jpg"},4367:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/ali3-00df970d77550b51c606be65feba1cdf.jpg"},4566:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img12-903259f6c9d53b73baf6b6de76e2e4f7.jpg"},4682:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit2_pcb1-3644342983fa00490c815a7384e43552.png"},5359:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit2_schematic-8623ffaae2005603cddf8ce9c5831e83.png"},5555:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit2_3D-69a63cff8247e62735cb68c8d006b69c.png"},5902:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img1-fb16c5c384d2fa05a8c49a5db0314973.jpg"},6029:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img15-a16a22ec5703a3a56b2a15f4fd4c8275.jpg"},6100:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img10-55c898831b9d968398c7fbd323c633df.jpg"},6556:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit1_schematic-1c62f9313eae92e17e7c741308af012b.png"},6659:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/Test_2_circuit1_pcb1-d562530314b8f2bc77f43b49438ec4f9.png"},6800:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img14-09c6318412e9bc3d3d47c63f3527abe2.jpg"},7731:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img13-43e72ca7469b33bc7488365258dda7a4.jpg"},7770:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img5-ee79776f3a6500ea57e901d93717496a.jpg"},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},8583:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img4-71e51dcd7b4d86866cc3d0aeefc038ed.jpg"},9334:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img9-5b1bd555896c63666cb006dcab7860c2.jpg"},9609:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/img2-26de3ec46a01659aa68b71e89eef9ecb.jpg"}}]);