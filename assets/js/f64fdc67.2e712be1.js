"use strict";(self.webpackChunktekbot=self.webpackChunktekbot||[]).push([[711],{8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var i=n(6540);const t={},s=i.createContext(t);function l(e){const r=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:r},e.children)}},8807:(e,r,n)=>{n.d(r,{A:()=>i});const i=n.p+"assets/images/page-ab11159f63f067f5e12a31ae4674ca02.png"},9911:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"preselection/final/computer","title":"Computer Science","description":"IT Domain \u2013 Intelligent Detection and Real-Time Web Monitoring","source":"@site/docs/preselection/final/computer.md","sourceDirName":"preselection/final","slug":"/preselection/final/computer","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/final/computer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/preselection/final/computer.md","tags":[],"version":"current","frontMatter":{},"sidebar":"preselectionSidebar","previous":{"title":"Electronic","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/final/electronic"},"next":{"title":"Mechanic","permalink":"/2025-Team-The_Winners-Docs/docs/preselection/final/mechanic"}}');var t=n(4848),s=n(8453);const l={},a="Computer Science",o={},c=[{value:"IT Domain \u2013 Intelligent Detection and Real-Time Web Monitoring",id:"it-domain--intelligent-detection-and-real-time-web-monitoring",level:2},{value:"\ud83c\udfaf Objectives",id:"-objectives",level:2},{value:"\ud83d\udcdd Summary",id:"-summary",level:2},{value:"\ud83d\udd0c Hardware",id:"-hardware",level:2},{value:"\ud83d\udcc1 Repository Structure",id:"-repository-structure",level:2},{value:"\ud83c\udf10 Technologies &amp; Architecture",id:"-technologies--architecture",level:2},{value:"\ud83e\udded System Architecture",id:"-system-architecture",level:3},{value:"\ud83d\udda5\ufe0f Web Interface",id:"\ufe0f-web-interface",level:2},{value:"\ud83d\udcbb Source Code",id:"-source-code",level:2},{value:"\ud83e\udde0 Arduino Embedded Logic",id:"-arduino-embedded-logic",level:3},{value:"KeepDataColor",id:"keepdatacolor",level:4},{value:"algoDistanceColor",id:"algodistancecolor",level:4},{value:"\ud83c\udf10 Flask Web Server",id:"-flask-web-server",level:3},{value:"\ud83d\uddbc\ufe0f Web Dashboard (HTML Template)",id:"\ufe0f-web-dashboard-html-template",level:3},{value:"\ud83e\uddea Results &amp; Testing",id:"-results--testing",level:2},{value:"\ud83d\udcda References",id:"-references",level:2},{value:"Arduino Documentation",id:"arduino-documentation",level:3},{value:"Flask &amp; Web Dashboard",id:"flask--web-dashboard",level:3},{value:"Hardware &amp; Design",id:"hardware--design",level:3},{value:"\ud83d\udc65 Team",id:"-team",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{Details:i}=r;return i||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"computer-science",children:"Computer Science"})}),"\n",(0,t.jsx)(r.h2,{id:"it-domain--intelligent-detection-and-real-time-web-monitoring",children:"IT Domain \u2013 Intelligent Detection and Real-Time Web Monitoring"}),"\n",(0,t.jsx)("p",{align:"center",children:(0,t.jsxs)(r.p,{children:[(0,t.jsx)("a",{href:"#-objectives",children:"\ud83c\udfaf Objectives"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-summary",children:"\ud83d\udcdd Summary"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-hardware",children:"\ud83d\udd0c Hardware"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-technologies--architecture",children:"\ud83c\udf10 Technologies & Architecture"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-web-interface",children:"\ud83d\udda5\ufe0f Web Interface"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-source-code",children:"\ud83d\udcbb Source Code"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-results--testing",children:"\ud83e\uddea Results & Testing"})," \u2022\r\n",(0,t.jsx)("a",{href:"#-documentation",children:"\ud83d\udcda Documentation"})]})}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-objectives",children:"\ud83c\udfaf Objectives"}),"\n",(0,t.jsxs)(r.p,{children:["The objective is to develop an intelligent conveyor system capable of identifying and sorting ",(0,t.jsx)(r.strong,{children:"4 types of waste"})," represented by colored cubes (green, yellow, red, blue).",(0,t.jsx)(r.br,{}),"\n","The system should:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Detect the presence of a waste item"}),"\n",(0,t.jsx)(r.li,{children:"Identify its color with a color sensor"}),"\n",(0,t.jsx)(r.li,{children:"Trigger the conveyor motor only when needed"}),"\n",(0,t.jsx)(r.li,{children:"Transmit real-time data to a web dashboard showing the count of each waste type"}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-summary",children:"\ud83d\udcdd Summary"}),"\n",(0,t.jsxs)(r.p,{children:["This project implements a smart waste-sorting conveyor using a ",(0,t.jsx)(r.strong,{children:"microcontroller (ATmega328P / Arduino Nano)"})," connected to a ",(0,t.jsx)(r.strong,{children:"color sensor"})," and a ",(0,t.jsx)(r.strong,{children:"presence detector"}),".",(0,t.jsx)(r.br,{}),"\n","An embedded program detects waste, identifies its color, and communicates the information to a Flask-based web interface in real time via serial communication.",(0,t.jsx)(r.br,{}),"\n","Administrators can monitor sorted waste quantities per color through a modern, responsive dashboard including the ",(0,t.jsx)(r.strong,{children:"TEKBOT"})," and ",(0,t.jsx)(r.strong,{children:"TRC 2025"})," logos."]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-hardware",children:"\ud83d\udd0c Hardware"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Component"}),(0,t.jsx)(r.th,{children:"Description"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Microcontroller"}),(0,t.jsx)(r.td,{children:"ATmega328P"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Color Sensor"}),(0,t.jsx)(r.td,{children:"TCS3472"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Presence Detection"}),(0,t.jsx)(r.td,{children:"KY-008 laser module with photodiode / LDR"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Conveyor Motor"}),(0,t.jsx)(r.td,{children:"DC motor controlled via driver (L298N)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Power Supply"}),(0,t.jsx)(r.td,{children:"Lithium battery block"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Waste Items"}),(0,t.jsx)(r.td,{children:"30 mm cubes (green, yellow, red, blue)"})]})]})]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-repository-structure",children:"\ud83d\udcc1 Repository Structure"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"smart_conveyor/\r\n\u251c\u2500\u2500 arduino/\r\n\u2502   \u251c\u2500\u2500 KeepDataColor.ino\r\n\u2502   \u2514\u2500\u2500 algoDistanceColor.ino  \r\n\u251c\u2500\u2500 web/\r\n\u2502   \u251c\u2500\u2500 app.py\r\n\u2502   \u251c\u2500\u2500 static/\r\n\u2502   \u251c\u2500\u2500 templates/\r\n\u2502   \u2502   \u2514\u2500\u2500 index.html\r\n\u251c\u2500\u2500 models/\r\n\u2502   \u2514\u2500\u2500 conveyor.sldprt\r\n\u251c\u2500\u2500 capture final/\r\n\u2502   \u2514\u2500\u2500 web_interface.png\r\n\u2514\u2500\u2500 README.md\n"})}),"\n",(0,t.jsx)(r.h2,{id:"-technologies--architecture",children:"\ud83c\udf10 Technologies & Architecture"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Layer"}),(0,t.jsx)(r.th,{children:"Tools / Technologies"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Embedded Logic"}),(0,t.jsx)(r.td,{children:"Arduino (C++)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Web Server"}),(0,t.jsx)(r.td,{children:"Flask (Python)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Frontend"}),(0,t.jsx)(r.td,{children:"HTML, CSS,JS"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Communication"}),(0,t.jsx)(r.td,{children:"Serial (USB) via pySerial"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Data Format"}),(0,t.jsx)(r.td,{children:"JSON / plain text"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Deployment"}),(0,t.jsx)(r.td,{children:"Localhost or RPi-hosted Flask server"})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"-system-architecture",children:"\ud83e\udded System Architecture"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-text",children:"+------------+         +-----------------+         +---------------------+     +---------------------+\r\n|  Sensor(s) | ----\x3e   |  Arduino/Nano    |  ---\x3e  |    Module wifi      | ---\x3e|  Flask Web Server   |\r\n| (Color + IR)|        | (ATmega328P)     |        |     (ESP-01)        |     |   (Data Collection +|\r\n+------------+         +-----------------+         |                     |     |   Visualization)    |\r\n                                                   +---------------------+     +---------------------+\n"})}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"\ufe0f-web-interface",children:"\ud83d\udda5\ufe0f Web Interface"}),"\n",(0,t.jsx)(r.p,{children:"The web interface displays:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"The total count of each waste type (green, yellow, red, blue)"}),"\n",(0,t.jsx)(r.li,{children:"Real-time updates upon detection"}),"\n",(0,t.jsx)(r.li,{children:"Embedded logos of TEKBOT and TRC 2025"}),"\n",(0,t.jsx)(r.li,{children:"A clean and responsive layout"}),"\n",(0,t.jsx)(r.li,{children:"Battery Display"}),"\n",(0,t.jsx)(r.li,{children:"Audio"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"Web Dashboard Interface",src:n(8807).A+"",width:"1667",height:"898"})}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-source-code",children:"\ud83d\udcbb Source Code"}),"\n",(0,t.jsx)(r.h3,{id:"-arduino-embedded-logic",children:"\ud83e\udde0 Arduino Embedded Logic"}),"\n",(0,t.jsx)(r.h4,{id:"keepdatacolor",children:"KeepDataColor"}),"\n",(0,t.jsx)(r.p,{children:"Before calibration, the user selects which color to calibrate (red, green, blue, yellow) via the serial monitor. For each color, the sensor takes several readings, normalizes the RGB values, and calculates the average. These reference values are stored in EEPROM for later use. The process ensures accurate color recognition by adapting to the specific cubes used. The code prints each reading and the final average to help the user verify calibration quality."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Voir plus..."}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp",children:'#include <Wire.h>\r\n#include <Adafruit_TCS34725.h>\r\n#include <EEPROM.h>\r\n\r\n// Initialisation du capteur TCS34725\r\nAdafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);\r\n\r\n// Structure pour stocker les valeurs de r\xe9f\xe9rence\r\nstruct ColorRef {\r\n  String name;\r\n  float r_ref;\r\n  float g_ref;\r\n  float b_ref;\r\n};\r\n\r\n// Tableau des couleurs \xe0 calibrer\r\nColorRef colors[] = {\r\n  {"Rouge", 0.0, 0.0, 0.0},\r\n  {"Vert", 0.0, 0.0, 0.0},\r\n  {"Bleu", 0.0, 0.0, 0.0},\r\n  {"Jaune", 0.0, 0.0, 0.0}\r\n};\r\nconst int numColors = 4;\r\nconst int numReadings = 10; // Nombre de lectures par couleur\r\nconst int eepromBaseAddr = 0; // Adresse de d\xe9part dans l\'EEPROM\r\n\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  while (!Serial); // Attendre que le moniteur s\xe9rie soit pr\xeat\r\n  if (tcs.begin()) {\r\n    Serial.println("Capteur TCS34725 d\xe9tect\xe9 !");\r\n  } else {\r\n    Serial.println("Erreur : capteur TCS34725 non d\xe9tect\xe9. V\xe9rifiez les connexions !");\r\n    while (1); // Boucle infinlisten\r\n\r\n    // Instructions pour l\'utilisateur\r\n    Serial.println("Programme de calibrage des couleurs.");\r\n    Serial.println("Entrez le num\xe9ro de la couleur \xe0 calibrer :");\r\n    Serial.println("1: Rouge, 2: Vert, 3: Bleu, 4: Jaune");\r\n  }\r\n}\r\n\r\nvoid loop() {\r\n  if (Serial.available() > 0) {\r\n    int choice = Serial.parseInt();\r\n    if (choice >= 1 && choice <= numColors) {\r\n      String colorName = colors[choice - 1].name;\r\n      Serial.print("Calibration pour "); Serial.print(colorName); Serial.println(". Placez l\'\xe9chantillon de couleur et attendez...");\r\n      \r\n      float r_sum = 0.0, g_sum = 0.0, b_sum = 0.0;\r\n      int validReadings = 0;\r\n\r\n      // Collecter numReadings lectures\r\n      for (int i = 0; i < numReadings; i++) {\r\n        uint16_t r, g, b, c;\r\n        tcs.getRawData(&r, &g, &b, &c);\r\n\r\n        // Normaliser les valeurs\r\n        float sum = r + g + b;\r\n        if (sum == 0) sum = 1; // \xc9viter la division par z\xe9ro\r\n        float r_norm = r / sum;\r\n        float g_norm = g / sum;\r\n        float b_norm = b / sum;\r\n\r\n        // V\xe9rifier si la lecture est valide (intensit\xe9 suffisante)\r\n        // if (c > 500) { // Seuil pour \xe9viter le bruit\r\n          r_sum += r_norm;\r\n          g_sum += g_norm;\r\n          b_sum += b_norm;\r\n          validReadings++;\r\n          \r\n          Serial.print("Lecture "); Serial.print(i + 1); \r\n          Serial.print(": R_norm="); Serial.print(r_norm, 3);\r\n          Serial.print(" G_norm="); Serial.print(g_norm, 3);\r\n          Serial.print(" B_norm="); Serial.print(b_norm, 3);\r\n          Serial.println();\r\n         // } else {\r\n         // Serial.println("Lecture ignor\xe9e : intensit\xe9 lumineuse trop faible.");\r\n        }\r\n        delay(500); // Attendre 500 ms entre les lectures\r\n      //}\r\n\r\n      // Calculer et afficher la moyenne\r\n      if (validReadings > 0) {\r\n        colors[choice - 1].r_ref = r_sum / validReadings;\r\n        colors[choice - 1].g_ref = g_sum / validReadings;\r\n        colors[choice - 1].b_ref = b_sum / validReadings;\r\n\r\n        Serial.print("Moyenne pour "); Serial.print(colorName); Serial.print(": ");\r\n        Serial.print("R_ref="); Serial.print(colors[choice - 1].r_ref, 3);\r\n        Serial.print(" G_ref="); Serial.print(colors[choice - 1].g_ref, 3);\r\n        Serial.print(" B_ref="); Serial.print(colors[choice - 1].b_ref, 3);\r\n        Serial.print(" (bas\xe9 sur "); Serial.print(validReadings); Serial.println(" lectures valides)");\r\n\r\n        // Sauvegarder dans l\'EEPROM\r\n        int addr = eepromBaseAddr + (choice - 1) * sizeof(ColorRef);\r\n        EEPROM.put(addr, colors[choice - 1]);\r\n      } else {\r\n        Serial.println("Erreur : aucune lecture valide pour cette couleur.");\r\n      }\r\n\r\n      // Demander la couleur suivante\r\n      Serial.println("\\nEntrez le num\xe9ro de la couleur suivante (1-4), ou 0 pour terminer :");\r\n    } else if (choice == 0) {\r\n      // Afficher toutes les valeurs de r\xe9f\xe9rence\r\n      Serial.println("\\nR\xe9sultats finaux des valeurs de r\xe9f\xe9rence :");\r\n      for (int i = 0; i < numColors; i++) {\r\n        Serial.print(colors[i].name); Serial.print(": ");\r\n        Serial.print("R_ref="); Serial.print(colors[i].r_ref, 3);\r\n        Serial.print(" G_ref="); Serial.print(colors[i].g_ref, 3);\r\n        Serial.print(" B_ref="); Serial.print(colors[i].b_ref, 3);\r\n        Serial.println();\r\n      }\r\n      Serial.println("Calibration termin\xe9e. Copiez ces valeurs dans un fichier.");\r\n      while (1); // Arr\xeater apr\xe8s la calibration\r\n    } else {\r\n      Serial.println("Choix invalide. Entrez 1-4 pour une couleur, ou 0 pour terminer.");\r\n    }\r\n    // Vider le tampon s\xe9rie\r\n    while (Serial.available() > 0) Serial.read();\r\n  }\r\n}\n'})})]}),"\n",(0,t.jsx)(r.h4,{id:"algodistancecolor",children:"algoDistanceColor"}),"\n",(0,t.jsx)(r.p,{children:"This code uses the previously calibrated reference values to identify the color of detected objects. For each sensor reading, it normalizes the RGB values and compares them to each reference color using Euclidean distance. The closest match is selected, provided the light intensity is sufficient and the distance is below a threshold. The detected color is printed to the serial monitor, allowing real-time tracking of waste sorting."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Voir plus..."}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp",children:'#include <Wire.h>\r\n#include <Adafruit_TCS34725.h>\r\n#include <EEPROM.h>\r\n#include <math.h>\r\n\r\n// Initialisation du capteur TCS34725\r\nAdafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);\r\n\r\n// Structure pour stocker les valeurs de r\xe9f\xe9rence\r\nstruct ColorRef {\r\n  String name;\r\n  float r_ref;\r\n  float g_ref;\r\n  float b_ref;\r\n};\r\n\r\n// Tableau des couleurs de r\xe9f\xe9rence (valeurs par d\xe9faut si EEPROM vide)\r\nColorRef colors[] = {\r\n  {"Rouge", 0.8, 0.1, 0.1},\r\n  {"Vert", 0.1, 0.8, 0.1},\r\n  {"Bleu", 0.1, 0.1, 0.8},\r\n  {"Jaune", 0.5, 0.45, 0.05}\r\n};\r\nconst int numColors = 4;\r\nconst int eepromBaseAddr = 0; // Adresse de d\xe9part dans l\'EEPROM\r\n\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  while (!Serial); // Attendre que le moniteur s\xe9rie soit pr\xeat\r\n  if (tcs.begin()) {\r\n    Serial.println("Capteur TCS34725 d\xe9tect\xe9 !");\r\n  } else {\r\n    Serial.println("Erreur : capteur TCS34725 non d\xe9tect\xe9. V\xe9rifiez les connexions !");\r\n    while (1); // Boucle infinie en cas d\'erreur\r\n  }\r\n\r\n  // Charger les valeurs de r\xe9f\xe9rence depuis l\'EEPROM\r\n  for (int i = 0; i < numColors; i++) {\r\n    ColorRef temp;\r\n    EEPROM.get(eepromBaseAddr + i * sizeof(ColorRef), temp);\r\n    // V\xe9rifier si les valeurs sont valides (non nulles et coh\xe9rentes)\r\n    if (temp.r_ref + temp.g_ref + temp.b_ref > 0.1) { // Somme non nulle\r\n      colors[i] = temp;\r\n    }\r\n  }\r\n\r\n  // Afficher les valeurs de r\xe9f\xe9rence utilis\xe9es\r\n  Serial.println("Valeurs de r\xe9f\xe9rence utilis\xe9es :");\r\n  for (int i = 0; i < numColors; i++) {\r\n    Serial.print(colors[i].name); Serial.print(": ");\r\n    Serial.print("R_ref="); Serial.print(colors[i].r_ref, 3);\r\n    Serial.print(" G_ref="); Serial.print(colors[i].g_ref, 3);\r\n    Serial.print(" B_ref="); Serial.print(colors[i].b_ref, 3);\r\n    Serial.println();\r\n  }\r\n}\r\n\r\nvoid loop() {\r\n  uint16_t r, g, b, c;\r\n  float r_norm, g_norm, b_norm;\r\n\r\n  // Lire les donn\xe9es brutes du capteur\r\n  tcs.getRawData(&r, &g, &b, &c);\r\n\r\n  // Normaliser les valeurs RVB\r\n  float sum = r + g + b;\r\n  if (sum == 0) sum = 1; // \xc9viter la division par z\xe9ro\r\n  r_norm = r / sum;\r\n  g_norm = g / sum;\r\n  b_norm = b / sum;\r\n\r\n  // Afficher les valeurs normalis\xe9es pour d\xe9bogage\r\n  Serial.print("R_norm: "); Serial.print(r_norm, 3);\r\n  Serial.print(" G_norm: "); Serial.print(g_norm, 3);\r\n  Serial.print(" B_norm: "); Serial.print(b_norm, 3);\r\n  Serial.print(" Clear: "); Serial.println(c);\r\n\r\n  // Trouver la couleur la plus proche\r\n  String detectedColor = "Inconnue";\r\n  float minDistance = 1000.0; // Valeur initiale \xe9lev\xe9e\r\n  for (int i = 0; i < numColors; i++) {\r\n    // Calculer la distance euclidienne\r\n    float distance = sqrt(\r\n      pow(r_norm - colors[i].r_ref, 2) +\r\n      pow(g_norm - colors[i].g_ref, 2) +\r\n      pow(b_norm - colors[i].b_ref, 2)\r\n    );\r\n\r\n    // Afficher la distance pour d\xe9bogage\r\n    Serial.print("Distance \xe0 "); Serial.print(colors[i].name); \r\n    Serial.print(": "); Serial.println(distance, 3);\r\n\r\n    // Mettre \xe0 jour la couleur d\xe9tect\xe9e si la distance est plus faible\r\n    if (distance < minDistance) {\r\n      minDistance = distance;\r\n      detectedColor = colors[i].name;\r\n    }\r\n  }\r\n\r\n  // V\xe9rifier le seuil de distance et l\'intensit\xe9 lumineuse\r\n  if (minDistance > 0.3 || c < 1000) {\r\n    detectedColor = "Inconnue (distance trop grande ou lumi\xe8re faible)";\r\n  }\r\n\r\n  // Afficher la couleur d\xe9tect\xe9e\r\n  Serial.print("Couleur d\xe9tect\xe9e : "); Serial.println(detectedColor);\r\n  Serial.println("---");\r\n\r\n  delay(1000); // Attendre 1 seconde avant la prochaine lecture\r\n}\n'})})]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h3,{id:"-flask-web-server",children:"\ud83c\udf10 Flask Web Server"}),"\n",(0,t.jsx)(r.p,{children:"This code connects an ESP8266 microcontroller to a Wi-Fi network using the provided SSID and password. It then periodically sends HTTP requests to a Flask web server running at a specified IP address and port. The ESP8266 uses the ESP8266WiFi and ESP8266HTTPClient libraries for Wi-Fi and HTTP communication. The ArduinoJson library is included for handling JSON data (though not used in this snippet). Every 2 seconds, the ESP8266 builds a request URL and sends a GET request to the Flask server\u2019s API endpoint, allowing real-time data transfer from the microcontroller to the web dashboard."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Voir plus..."}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# app.py\r\n# Flask server to receive and process data from Arduino\r\n#include <ESP8266WiFi.h>\r\n#include <ESP8266HTTPClient.h>\r\n#include <WiFiClient.h>\r\n#include <ArduinoJson.h> // N\xe9cessaire pour envoyer du JSON\r\n\r\n// --- Configuration Wi-Fi ---\r\n//const char* ssid = "Moov -Africa";         // Remplacez par le nom de votre r\xe9seau Wi-Fi\r\n//const char* password = "@@password@"; // Remplacez par le mot de passe de votre r\xe9seau Wi-Fi\r\n\r\nconst char* ssid = "MOOVAFRICA_320139";         // Remplacez par le nom de votre r\xe9seau Wi-Fi\r\nconst char* password = "b2652aa6"; // Remplacez par le mot de passe de votre r\xe9seau Wi-Fi\r\n\r\n// --- Configuration du serveur Flask ---\r\n// IMPORTANT : Remplacez par l\'adresse IP de votre machine qui ex\xe9cute le serveur Flask\r\n// et le port que Flask utilise (par d\xe9faut 5000).\r\n// N\'utilisez PAS "localhost" ou "127.0.0.1" car c\'est l\'adresse de l\'ESP lui-m\xeame.\r\nconst char* flaskServerHost = "192.168.1.100";\r\nconst int flaskServerPort = 5000;\r\nconst char* apiEndpoint = "/api/set?color=blue"; // Le chemin de l\'API sur votre serveur Flask\r\n\r\n// String apiEndpoint = "";\r\n\r\n// http://192.168.1.100:5000/api/set?color=blue\r\n\r\n// --- Variables de donn\xe9es (simul\xe9es) ---\r\nunsigned long previousMillis = 0;\r\nconst long interval = 2000; // Intervalle d\'envoi des donn\xe9es (en ms), ici toutes les 5 secondes\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  delay(10);\r\n  Serial.println();\r\n  Serial.print("Connecting to ");\r\n  Serial.println(ssid);\r\n\r\n  WiFi.begin(ssid, password);\r\n\r\n  // Attendre la connexion Wi-Fi\r\n  int retries = 0;\r\n  while (WiFi.status() != WL_CONNECTED) {\r\n    delay(500);\r\n    Serial.print(".");\r\n    retries++;\r\n    if (retries > 20) { // Si apr\xe8s 10 secondes \xe7a ne se connecte pas\r\n      Serial.println("\\nFailed to connect to WiFi. Please check SSID/Password and signal.");\r\n      //while(true); // Bloque l\'ex\xe9cution\r\n    }\r\n  }\r\n\r\n  Serial.println("");\r\n  Serial.println("WiFi connected");\r\n  Serial.println("IP address: ");\r\n  Serial.println(WiFi.localIP());\r\n}\r\n\r\nvoid loop() {\r\n  unsigned long currentMillis = millis();\r\n\r\n  if (currentMillis - previousMillis >= interval) {\r\n    previousMillis = currentMillis;\r\n\r\n    // // --- Mettre \xe0 jour les donn\xe9es (simul\xe9es pour l\'exemple) ---\r\n    // temperature += 0.1; // Simule une petite variation\r\n    // if (temperature > 30.0) temperature = 20.0;\r\n    // humidity = (humidity + 1) % 100; // Simule une variation de l\'humidit\xe9\r\n\r\n    \r\n    // DynamicJsonDocument doc(1024);\r\n\r\n    // doc["temperature"] = temperature;\r\n    // doc["humidity"] = humidity;\r\n\r\n    String jsonString;\r\n    // serializeJson(doc, jsonString);\r\n\r\n    // Serial.print("Sending JSON: ");\r\n    // Serial.println(jsonString);\r\n\r\n    // --- Envoyer la requ\xeate HTTP POST ---\r\n    WiFiClient client;\r\n    HTTPClient http;\r\n\r\n    // Construire l\'URL compl\xe8te\r\n\r\n    // apiEndpoint = "set?color=" + color + "&battery=" + String(batteryLevel);\r\n\r\n    String serverPath = "http://" + String(flaskServerHost) + ":" + String(flaskServerPort) + String(apiEndpoint);\r\n\r\n    Serial.print("[HTTP] begin...\\n");\r\n    if (http.begin(client, serverPath)) {  // HTTP\r\n      Serial.print("[HTTP] GET...\\n");\r\n      // Sp\xe9cifier le type de contenu comme JSON\r\n      // http.addHeader("Content-Type", "application/json");\r\n\r\n      int httpCode = http.GET();\r\n\r\n      // httpCode will be negative on error\r\n      if (httpCode > 0) {\r\n        // HTTP header has been send and Server response header has been handled\r\n        Serial.printf("[HTTP] GET... code: %d\\n", httpCode);\r\n\r\n        // file found at server\r\n        if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {\r\n          String payload = http.getString();\r\n          Serial.println(payload);\r\n        }\r\n      } else {\r\n        Serial.printf("[HTTP] POST... failed, error: %s\\n", http.errorToString(httpCode).c_str());\r\n      }\r\n\r\n      http.end();\r\n    } else {\r\n      Serial.printf("[HTTP] Unable to connect\\n");\r\n    }\r\n  }\r\n\r\n  // Permettre au syst\xe8me Wi-Fi de fonctionner en arri\xe8re-plan\r\n  // Important pour maintenir la connexion stable\r\n  yield();\r\n}\n'})})]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h3,{id:"\ufe0f-web-dashboard-html-template",children:"\ud83d\uddbc\ufe0f Web Dashboard (HTML Template)"}),"\n",(0,t.jsx)(r.p,{children:"This HTML template creates a web dashboard for monitoring the smart conveyor system. It displays the counts of each waste type (red, green, blue, yellow) using cards, shows the total collected waste, and includes a histogram chart for waste distribution. The dashboard features the TEKBOT and TRC logos, a battery status indicator, and a button for audio reports. The layout is responsive and styled with external CSS and Font Awesome icons, providing a modern and user-friendly interface for real-time waste tracking."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Voir plus..."}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-html",children:'\x3c!-- templates/index.html --\x3e\r\n\x3c!-- Dashboard layout with TEKBOT and TRC logos --\x3e\r\n<!DOCTYPE html>\r\n<html lang="en">\r\n<head>\r\n    <meta charset="UTF-8" />\r\n    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>\r\n    <title>TekBot | DashBoard</title>\r\n    <link rel="stylesheet" href="../static/style.css"/>\r\n    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>\r\n    <script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>\r\n</head>\r\n<body>\r\n    <nav class="navbar">\r\n    <div class="navbar-left">\r\n        <img src="../static/logo.png" alt="Logo Tekbot" class="logo" />\r\n    </div>\r\n    <div class="navbar-utils">\r\n        <div class="battery-info">\r\n            <i class="fas fa-battery-three-quarters battery-icon"></i>\r\n            <span class="battery-level">--%</span>\r\n        </div>\r\n        <button class="volume-btn" onclick="lireRapport()">\r\n            <i class="fas fa-volume-up volume-icon"></i>\r\n        </button>\r\n    </div>\r\n    <div class="navbar-right">\r\n        <img src="../static/trc.png" alt="Logo TRC" class="logo" />\r\n    </div>\r\n</nav>\r\n\r\n  <div class="dashboard-container">\r\n    <div class="card-section">\r\n\r\n      <div class="card red">\r\n        <div class="card-header">\r\n          <h3>Red Waste</h3>\r\n          <i class="fa-solid fa-trash-can waste-icon"></i>\r\n        </div>\r\n        <p class="value"><span id="rouge-count">{{ red }}</span></p>\r\n      </div>\r\n\r\n      <div class="card green">\r\n        <div class="card-header">\r\n          <h3>Green Waste</h3>\r\n          <i class="fa-solid fa-trash-can waste-icon"></i>\r\n        </div>\r\n        <p class="value1"><span id="vert-count">{{ green }}</span></p>\r\n      </div>\r\n\r\n      <div class="card blue">\r\n        <div class="card-header">\r\n          <h3>Blue Waste</h3>\r\n          <i class="fa-solid fa-trash-can waste-icon"></i>\r\n        </div>\r\n        <p class="value2"><span id="bleu-count">{{ blue }}</span></p>\r\n      </div>\r\n\r\n      <div class="card yellow">\r\n        <div class="card-header">\r\n          <h3>Yellow Waste</h3>\r\n          <i class="fa-solid fa-trash-can waste-icon"></i>\r\n        </div>\r\n        <p class="value3"><span id="jaune-count">{{ yellow }}</span></p>\r\n      </div>\r\n\r\n     \x3c!-- Carte du Total (nouvelle structure) --\x3e\r\n    <div class="total-card">\r\n        <div class="total-content">\r\n            <i class="fas fa-dumpster total-icon"></i>\r\n            <div class="total-text">Total des d\xe9chets collect\xe9s :</div>\r\n            <div class="total-value" id="total-count">{{ red + green + blue + yellow }}</div>\r\n        </div>\r\n    </div>\r\n    \r\n\r\n    \x3c!-- Graphique ( --\x3e\r\n    <div class="chart-fullwidth">\r\n        <h2 class="chart-title">Waste Distribution</h2>\r\n        <canvas id="wasteHistogram"></canvas>\r\n    </div>\r\n  <script src="../static/script.js"><\/script>\r\n</body>\r\n</html>\r\n\r\n...\n'})})]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-results--testing",children:"\ud83e\uddea Results & Testing"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Test Scenario"}),(0,t.jsx)(r.th,{children:"Expected Result"}),(0,t.jsx)(r.th,{children:"Outcome"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Waste detected and identified correctly"}),(0,t.jsx)(r.td,{children:"Color is logged and counted"}),(0,t.jsx)(r.td,{children:"\u2705 Success"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Motor activates only when needed"}),(0,t.jsx)(r.td,{children:"Conveyor runs during detection"}),(0,t.jsx)(r.td,{children:"\u2705 Success"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Real-time interface update"}),(0,t.jsx)(r.td,{children:"Dashboard shows new counts instantly"}),(0,t.jsx)(r.td,{children:"\u2705 Success"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Interface displays all 4 types clearly"}),(0,t.jsx)(r.td,{children:"All colors tracked"}),(0,t.jsx)(r.td,{children:"\u2705 Success"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"TRC & TEKBOT logos visible"}),(0,t.jsx)(r.td,{children:"Logos displayed"}),(0,t.jsx)(r.td,{children:"\u2705 Success"})]})]})]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-references",children:"\ud83d\udcda References"}),"\n",(0,t.jsx)(r.h3,{id:"arduino-documentation",children:"Arduino Documentation"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://docs.arduino.cc/",children:"Arduino Official Documentation"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://learn.adafruit.com/adafruit-color-sensors/overview",children:"Adafruit TCS34725 Color Sensor Guide"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://www.arduino.cc/en/Reference/EEPROM",children:"EEPROM Library Reference"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://www.arduino.cc/en/Reference/Serial",children:"Serial Communication Reference"})}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"flask--web-dashboard",children:"Flask & Web Dashboard"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://flask.palletsprojects.com/",children:"Flask Documentation"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://www.chartjs.org/docs/latest/",children:"Chart.js Documentation"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://fontawesome.com/",children:"Font Awesome Icons"})}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"hardware--design",children:"Hardware & Design"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://ww1.microchip.com/downloads/en/devicedoc/atmel-42735-8-bit-avr-microcontroller-atmega328-328p_datasheet.pdf",children:"ATmega328P Datasheet"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://components101.com/modules/ky-008-laser-module",children:"KY-008 Laser Module Info"})}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.a,{href:"https://lastminuteengineers.com/l298n-dc-stepper-driver-arduino-tutorial/",children:"L298N Motor Driver Guide"})}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"-team",children:"\ud83d\udc65 Team"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Marzoukath AGBODJA"}),"\n",(0,t.jsx)(r.li,{children:"If\xe8 Leonce COMLAN"}),"\n",(0,t.jsx)(r.li,{children:"Larissa CHATIGRE"}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:["Final Project \u2013 TEKBOT Robotics Challenge 2025",(0,t.jsx)(r.br,{}),"\n","Domain: IT",(0,t.jsx)(r.br,{}),"\n","Stack: Arduino (C++) + Flask + HTML/CSS"]}),"\n"]}),"\n",(0,t.jsx)("p",{align:"center",children:(0,t.jsx)("sub",{children:"\xa9 2025 TEKBOT Robotics Challenge \u2013 All Rights Reserved."})})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);